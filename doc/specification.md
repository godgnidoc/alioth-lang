# 前言

编程语言的设计始终是计算机领域的核心问题之一，从机器语言到低级语言再到高级语言，编程语言的进化历程从未停止过。如今，已知现存于世的编程语言种类已经超过自然语言的种类，基本能够满足任何类型的软件项目开发需求。然而每天仍有人尝试开发更先进的编程语言，从地下室里疯狂的极客到引领世界技术走向的商业巨头，编程语言的设计从来都不是满足需求即可，而是看到看不到的需求。

根据不同的侧面，高级语言可以存在若干分类形式，解释型与编译型，强类型与弱类型，指令式与函数式等。众多分类中的主流也在历史的长河中不断交替演化。如今包括Microsoft，Jetbrains，Facebook，Google在内的若干商界巨头都在开发自己的新型高级编程语言，关于编程语言的话题从来没有冷却过。

Alioth，作为一款面向对象的编译型强类型编程语言，挑战抽象本身的动态性，尝试支持超越编译周期的动态统一抽象体系。本书奉行概念先行的原则，向大家介绍了Alioth编程语言的设计。

限于篇幅，为了专注于Alioth编程语言特性的介绍，本文不得不假设您已经具备C++或其他类似等级的面向对象的高级编程语言的基础知识。

# 目录

- [前言](#前言)
- [目录](#目录)
- [第一章 开始](#第一章-开始)
  - [第一节 使用Alioth工作](#第一节-使用alioth工作)
  - [第二节 Alioth程序模型](#第二节-alioth程序模型)
  - [第三节 Alioth源码结构](#第三节-alioth源码结构)
- [第二章 编译资源管理](#第二章-编译资源管理)
  - [第一节 编写模块](#第一节-编写模块)
  - [第二节 包](#第二节-包)
  - [第三节 仓库](#第三节-仓库)
  - [第四节 工作空间](#第四节-工作空间)
- [第三章 Alioth基础](#第三章-alioth基础)
  - [第一节 基础概念](#第一节-基础概念)
  - [第二节 数据类型基础](#第二节-数据类型基础)
    - [基础数据类型](#基础数据类型)
    - [结构数据类型](#结构数据类型)
    - [枚举数据类型](#枚举数据类型)
    - [指针数据类型](#指针数据类型)
    - [接口数据类型](#接口数据类型)
    - [函数类型](#函数类型)
  - [第三节 函数与方法](#第三节-函数与方法)
  - [第四节 量](#第四节-量)
  - [第五节 变量类型](#第五节-变量类型)
    - [实体](#实体)
    - [数组](#数组)
    - [引用](#引用)
    - [右值引用](#右值引用)
  - [第六节 表达式基础](#第六节-表达式基础)
    - [运算符基础](#运算符基础)
    - [lambda表达式](#lambda表达式)

# 第一章 开始

`Alioth`是支持反射机制的面向对象的静态类型编程语言。

- `Alioth`的类型系统可以动态扩展。
- `Alioth`的语法对排版进行了限制。
- `Alioth`提供若干语法糖编码简单。

## 第一节 使用Alioth工作

使用Alioth编程语言可以参与大多数软件项目的开发，使用编译器从Alioth源代码可以产生单一的二进制编译产物。

您可以使用包管理工具安装或发布Alioth开发包。开发包中可以包含具有复用性的源码或编译产物以及对应的文档。编译器能够从工作路径和系统路径搜索已经被安装的开发包并使用其中的编译资源。

运行Alioth编译器编译Alioth源代码时，您需要一个正确的路径结构作为当前工作空间，Alioth编程语言的一些特性的正确实现依赖于此。Alioth编译器提供了初始化工作区的功能来协助您构造正确的工作路径结构。

~~~bash
#!/bin/bash

alioth --init hello
cd hello
~~~

我们会在关于工作空间的话题中详细了解编译器刚刚都做了些什么。现在，我们只需要在`hello/src`路径下创建我们的第一份`Alioth`源代码`hello/src/main.alioth`。

~~~alioth
module HelloWorld

using module stdio from 'alioth.stdlib'

main() => int32 {
    stdio.println("Hello world !")
}
~~~

这份源码实现了一个经典的`Hello world`程序，我们稍后再来剖析源码的细节，现在让我们体会一下成功的喜悦。

~~~bash
#!/bin/bash

alioth HelloWorld : run_me
~~~

编译器为我们产生了一个名为`run_me`的可执行程序，存放在`bin`路径下，我们现在来执行它。

~~~bash
#!/bin/bash

./bin/run_me
~~~

不出意外，你已经看到`Hello world !`跃然控制台，下一节我们会讨论上述活动中所涉及的概念，以及这些概念所体现的抽象思想。

## 第二节 Alioth程序模型

为了更好的支持Alioth编程语言的各种语法特性，我们对一些开发活动中涉及到的环节进行了抽象，我们将其总称为Alioth程序模型。

首先，编译指令`alioth HelloWorld : run_me`可以理解为`编译HelloWorld模块，输出到run_me文件`。

编译指令中没有提及源代码文件，而是指定了欲编译的`模块`。这是因为，编译资源管理的最小抽象单元就是`模块`。

模块是抽象概念，在工作空间内，一个庞大的模块可能需要多份源代码文件来共同描述，编译器会分析源码和模块的对应关系并按需读取源码文件。

在编译过程中产生目标代码文件时，一个模块仅对应产生一个目标代码文件，并最终参与链接。

实际上，在源代码层面上，对外部代码的依赖和引用也是以模块为单位进行的，Alioth应用程序完全由模块构成，没有任何同等级的其他抽象概念。

和Alioth工作流程相关的概念还包括`包`和`仓库`等，当我们足够深入Alioth时，会讨论这些话题。

## 第三节 Alioth源码结构

在真正开始学习Alioth编程语言之前，我们可以粗略浏览一下`Alioth`编程语言的源码文档中都可以写入哪些内容。

~~~alioth
module HelloWorld

using module stdio from 'alioth.stdlib'

main() => int32 {
    stdio.println("Hello world !")
}
~~~

上述是我们在第一节中用于实现HelloWorld功能的源码，一共七行。这份七行的源码可以被分为两个部分，`模块签名`和`正文`；

模块签名指的是前三行代码：

~~~alioth
module HelloWorld

using module stdio from 'alioth.stdlib'
~~~

模块签名指定了当前源码所属的模块，并且描述了这个模块与其他模块之间的依赖关系，并且详细解释了如何使用这些依赖。

第4行到第7行源码实现了一个名为`main`的方法，语法看起来和`TypeScript`语言有几分神似。

实际上，在一份Alioth源码中，您可以书写任何形式的定义，以及任何形式的实现，当然了这些抽象结构都必须属于当前模块。

对上述代码结构的剖析到这里就已经差不多了，最后您需要注意的是，Alioth是面向对象的编程语言，它并不提供面向过程的机制，也就是说，并不存在全局函数或全局变量。

基于上述描述，您一定会对我们的源码产生困惑，因为我们的`main`方法看起来并不属于任何一个类。

实际上，这是一个语法糖，模块中，与模块同名的类被称为`透明类`，它用于结构化的描述当前模块。在不需要被其他模块访问的情况下，透明类以及透明类中的任何声明都可以省略。这样的设计方便您对一小段代码进行测试，快速试验您的新想法，避免打扰您的思路。

既然说到这了，我们不得不展示一下，不使用这个语法糖时，源码看起来是什么样子的。

~~~alioth
module HelloWorld

using module stdio from 'alioth.stdlib'

class HelloWorld {
    main() => int32
}

HelloWorld.main() => int32 {
    stdio.println("Hello world !")
}
~~~

# 第二章 编译资源管理

本章初步讨论编译资源的管理，如果您更关心编码的细节，本章的第二节以及之后的内容都可以暂时跳过。

## 第一节 编写模块

模块是一个抽象概念，它在编码，编译，链接等不同阶段具有不同的体现形式。模块的概念贯穿了Alioth抽象体系，将不同问题域中的抽象概念连接起来。

Alioth源码必须从`模块签名`语法结构开始，在它之前，除了注释和空白符以外任何语法结构都是非法的。

模块签名描述了模块的名称，模块对其他模块的依赖关系。如果一个模块分散在若干份源码中，那么模块签名中的依赖关系也可以分散开写，不影响实际含义。

模块签名由`module`关键字引领，跟随一个模块名称；最简单的模块签名如下：

~~~alioth
module Hi
~~~

可选地，可以在模块签名后面追加若干`依赖描述`语法结构，来描述模块对其他模块的依赖关系。

依赖描述语句由关键字`using`引领，包含欲导入的模块名，模块所在包标识符以及可选的模块别名

~~~alioth
using netty from "godgnidoc.template" as net
~~~

特别地，如果依赖项的别名为`this`则依赖项中的符号均被注入当前模块，依赖项便不具备名称。

如下代码展示了一个相对复杂的模块签名。

~~~alioth
module iTalk

using module stdio from 'alioth.stdlib' as this
using module jsonz from 'godgnidoc.utils" as json
using module agent from 'godgnidoc.utils"
~~~

在上面的讨论中，我们遇到了一些依赖需要指定它所属的包，关于包的使用，我们详见下一节。

## 第二节 包

在组织编译资源时，一个模块对应于若干源码文件，当发布应用程序编程库时若干个相关联的模块总是被一起下载，一起使用。我们使用包来集中管理若干个相关联的模块。

从实质角度，包是对编译资源的集中管理单位，其中可以包含源码，文档，编译产物等内容。从抽象角度，包是模块的集合。我们推荐使用`包`的形式构建并发布您开发的Alioth编程库。如此您就能享受Alioth仓库机制为您提供的版本管理，发布和下载服务了。

应当注意，Alioth仓库提供的版本管理功能不同于`git`等版本管理工具，Alioth仓库仅对发布版本进行管理，请不要依赖Alioth仓库来保护您的源码。

Alioth使用`仓库`管理`包`，当您安装了Alioth编译器，您会获得一个内置在Alioth编译器安装路径的仓库，称为`根仓库`。

`根仓库`中的`包`可以被任何Alioth项目引用。您也可以在项目本地建立仓库，对于同名的包，Alioth编译器优先使用`本地仓库`中的包。

在工作过程中，我们可以使用5个维度来唯一确定一个包：

- `发布者`

  同一个发布者发布的包会被集中管理，起到命名空间的作用。在绝大多数情况下，发布者是用于确定一个包的必须信息之一。

  发布者是一个平坦的字符串，可由英文字母，数字和下划线构成。
- `包名称`

  用于确定一个包的必须信息，可由英文字母，数字和下划线构成。
- `架构`
  - `x86`
  - `x86_64`
  - `arm_v7`
  - `...`

  包对应的平台架构，通常默认为当前架构，不是必须给出的信息。
- `系统`
  - `none`
  - `windows`
  - `linux`
  - `...`

  包对应的操作系统，通常默认为当前操作系统，不是必须给出的信息。
- `版本`

  包的版本号的格式是三段式：`major.minor.patch`，每段版本号升级的含义如下：

  - `patch`表示对当前架构进行小修补，小优化，向下兼容。
  - `minor`表示在当前体系下增添特性，向下兼容。
  - `major`表示重大升级，向下不兼容或体系变化。

我们通常在工作空间的配置文件中指定开发包的版本、系统和架构，而在编码时，我们通常只需要考虑包的发布者和名称。

## 第三节 仓库

Alioth始终使用`仓库`来集中管理`包`，编译器能够直接使用的仓库包括`根仓库`和`本地仓库`。

您也可以使用包管理工具从`远程仓库`下载安装被发布的`包`，安装指令看起来长这样：

~~~bash
#!/bin/bash

alioth package: -i godgnidoc.jsonz
~~~

您可以带上更多参数执行指令来安装某个特定版本，平台或系统对应的包；关于更详细的指令格式可以在编译器使用手册上找到答案。

如果您想发布您的包到某个远程仓库，首先您需要确保将`公钥`送入该远程仓库。具体该如何实现这一点，取决于该远程仓库的运营者希望您做什么。

当您完成了发布者身份的注册，推送包的指令看起来长这样：

~~~bash
#!/bin/bash

alioth package: --publish jetweb
~~~

`jetweb`是您在`packages.json`文件中声明的一个包，关于这个包的详细信息都写在这份文件中，具体格式您可以在编译器手册中找到描述。

上述指令会将一个包发布到所有的已知远程仓库，在编译器的根目录有一个配置文件记录了这些仓库的相关信息。

本书更着重讲解Alioth编程语言，更多关于编译器功能使用方法请参见`Alioth编译器手册`。

## 第四节 工作空间

Alioth始终要求您在一个干净整洁，结构正确的工作空间开始您的工作。Alioth编译器对编译过程中所涉及的所有资源的部署规则进行了详细的设定，包括编译产物的存放路径也有详细的规定。

作出如此详细的规定自然不是为了束缚开发者的手脚，而是为了对所有编译资源中包含的信息进行充分的利用。甚至是编译产物，在编译期间也可能被读取，分析。除此之外，严格的路径安排也有助于Alioth编译器对资源进行自动管理，在封装发布和安装一个包的时候能够减少您的工作量。

综上，Alioth规定工作空间中有9个标准子路径：

- `arc`：用于存放作为编译产物的静态链接库。
- `bin`：用于存放作为编译产物的可执行文件。
- `doc`：用于存放说明文档。
- `inc`：用于存放头文件。
- `lib`：用于存放作为编译产物的动态链接库。
- `obj`：用于存放编译中间产物，比如目标代码文件。
- `repo`：用作本地仓库，管理本地安装的包。
- `src`：用于存放源文件。
- `test`：用于存放测试单元。

Alioth语言在设计上倾向于将头文件和源文件分开编写的源码模型。Alioth编程语言禁止在定义语法结构中写入算法实现。这是因为，我们认为一份干净的定义文件有助于团队协作，并且能够加快编译速度。

# 第三章 Alioth基础

本章讲解Alioth编程语言的基础内容，讲解了Alioth编程语言是如何设计和实现编程语言的必备要素的。我们对Alioth编程语言的类型系统进行了初探，了解了一些基础语法结构的书写，为后续章节探索高级语法特性做准备。

## 第一节 基础概念

在Alioth编程语言中，我们对`变量`概念有严格的定义，`变量`是语言层面的抽象概念，是借以操作内存中`对象`的媒介。

而`对象`则是属性的集合，在Alioth编程语言中，函数，类型均是一等公民，这意味着一个属性可以是一个函数也可以是一个类型。

虽然没有多少差别，但是在Alioth中，我们更喜欢将定义在类中的成员函数称为`方法`。这是因为数学上，函数概念体现了仅与输入相关的输出映射。但是随着编程抽象层次越来越高，大多数函数都不能做到输出或者说行为仅取决于参数。故而，我们希望使用一个更通用的术语进行我们的讨论。

`类型`在Alioth中被分为`数据类型`和`变量类型`两个方面。

变量类型相对简单，它体现了变量操作对象时的行为模式，体现在语义上。变量类型包括`实例`，`数组`，`引用`以及`右值引用`四种，在后面会有详细的讨论。

`数据类型`实际上包含两个部分，`本类型数据的取值空间`，以及`本类型数据能够参与的运算`。显然数据类型实际上就是集合论中讨论的`运算系统`。当一个函数的参数或返回值包含了不同的数据类型，两个`运算系统`就被桥接起来，所有的数据类型通过函数和方法交织在一起形成的`复杂的运算系统`就是一个应用程序在类层面上的抽象全貌。

实际上，`数据类型`不仅定义了对象的取值空间，也定义了对象的内存布局。而Alioth构造了一种可扩展的数据结构来描述这样的内存布局，这是Alioth类型动态化的基础，在后续讨论高级语法特性时会有更加详细的描述。模块

最后一条值得注意的细节，Alioth的语法将会拒绝您在类定义中书写函数实现。这是一个语法盐，为了使得Alioth源码更加整洁可维护。为了使这个语法盐不会过多打扰您的编码过程，我们适当预留了一些语法糖，在后续章节将会有所提及。

## 第二节 数据类型基础

Alioth数据类型包括`基础数据类型`、`指针数据类型`、`枚举数据类型`、`结构数据类型`、`接口数据类型`和`函数类型`，其中只有接口数据类型是抽象的，不能实例化的。

Alioth认为，数据类型的概念包含了数据结构以及行为模式两方面。数据结构描述了一个对象在内存中的布局，而行为模式则描述了对象能够参与何种运算。

### 基础数据类型

Alioth基础数据类型包含8种整数数据类型，两种浮点数数据类型，布尔数据类型和空数据类型，详情如下：

|类型|描述|值域|位宽|type id|
|---|---|---|---|---|
|`void`|空类型|||0|
|`int8`|带符号位整数|$[-128,127]$|8 bits|1|
|`int16`|带符号位整数|$[-2^{15},2^{15}-1]$|16 bits|2|
|`int32`|带符号位整数|$[-2^{31},2^{31}-1]$|32 bits|3|
|`int64`|带符号位整数|$[-2^{63},2^{63}-1]$|64 bits|4|
|`uint8`|无符号位整数|$[0,2^{8}-1]$|8 bits|5|
|`uint16`|无符号位整数|$[0,2^{16}-1]$|16 bits|6|
|`uint32`|无符号位整数|$[0,2^{32}-1]$|32 bits|7|
|`uint64`|无符号位整数|$[0,26^{64}-1]$|64 bits|8|
|`float32`|IEEE754单精度浮点数|$[-3.4e38,3.4e38]$|32 bits|9|
|`float64`|IEEE754双精度浮点数|$[-1.7e308,1.7e308]$|64 bits|10|
|`bool`|布尔类型|$\{true,false\}$|32 bits|11|

上表所示的`type id`字段用于支持运行时类型识别机制，我们会在后续章节详细讨论Alioth中的`类型系统动态化`。

### 结构数据类型

`结构数据类型`是`复合数据类型`的一种，由若干数据结构按照指定顺序排列组合而成。在Alioth编程语言中，`结构数据类型`会伴随`类定义`产生，通过书写`类定义`可以描述结构数据类型的`内存布局`和`行为模式`。

实际上，伴随类定义产生的结构数据类型有两个：其一是类实例化时所使用的`实例数据结构(Instance)`；其二则是被存储于静态数据区，用于描述类自身特性的`实体数据结构(Entity)`。

一个合法的类定义可以包含很多相关描述，包括`模板类`、`定义谓词`、`定义分支`、`属性声明`和`方法声明`等。我们会在后续的高级话题中讨论这些概念，如下代码展示了如何在Alioth中定义一个简单的类。

~~~
class Person {
    name string
    const gender Gender
    age int8
    height float32
    weight float32
    walk( distance float32 ) &Person
}
~~~

上述源码由`class`关键字引导了一个名为`Person`的类定义语句，`Person`类的每一个实例将拥有属于自己的5个属性。

可以简单分析Alioth中关于属性声明的语法规则，书写格式为`变量类型 属性名 数据类型`。属性声明之间不需要任何分割。

除了类定义，书写`立即对象`也能产生匿名的结构数据类型。立即对象中可以携带属性和方法，甚至可以继承已经定义的类，主要用于与`接口`概念相结合，为Alioth编码提供极大的自由度。

### 枚举数据类型

枚举数据类型的作用是限定一个量的取值域以及强调每一个取值的语义。在Alioth中，我们更加强调后者。

Alioth的枚举定义不会像`C/C++`那样将枚举符号注入父作用域的命名空间。

Alioth的枚举定义如下述代码所示：

~~~
enum Gender { 
    Male = 4 
    Female 
    Unknown 
}
~~~

### 指针数据类型

指针数据类型的行为模式保留了`C/C++`风格的原始指针的特性。指针数据类型不能够被预先定义，只能通过类型表达式基于已知类型表示。

在类型表达式中，将星号(*)前缀于另一个类型表达式即可表达指针数据类型，使用`const`关键字前缀于指针数据类型可以约束指针只拥有读取权限。

常见指针数据类型表达式的书写形式如下：

~~~
*int32
**int8
~~~

### 接口数据类型

`接口`是Alioth中用于实现泛型编程的重要概念，Alioth的`接口`遵循`鸭子模式`。

接口可以声明属性和方法，凡是声明了同类型同名成员的定义，即可被对应的接口引用。

接口引用与实际对象之间使用`行为`衔接，`行为`是Alioth编译器自动产生的隐藏结构，其中的信息描述了一个接口引用应该如何对对象的内部成员进行寻址。

关于接口应该如何定义以及接口可以如何定义，我们会在后续章节详细讨论。

### 函数类型

`函数类型`包含了函数返回值类型，函数参数类型，函数`this`类型等信息。

函数入口指针的数据类型即是`函数类型`，如下代码展示了几种常见的`函数类型表达式`：

~~~
(any,any):any
(this *This, T1, T2):T3
(string, ... args):int32
~~~

值得注意的是，在第一个参数数据类型之前加`this`关键字标记，可以声明成员函数类型。

函数类型的概念很重要，它在构造`仿函数(functor)`时被使用，我们会在后续章节详细讨论。

## 第三节 函数与方法

Alioth并没有很严格的区分`函数`和`方法`的概念。在习惯上，我们认为`函数`的行为能像它在数学领域里一样，它的输出仅随参数变化而变化，而`方法`则体现了在一种对象上能够进行的运算，或是一个对象能够执行的行为。

您可以通过书写方法签名来声明一个方法的存在，通过书写方法实现可以向编译器描述方法内部的具体算法。模块自身的方法不需要声明，您可以直接书写模块方法的实现，编译器会为您自动生成对应的方法签名。

方法签名需要被书写在类定义中，由方法名领起，跟随参数列表，返回值类型，样例代码如下：

~~~
class Person {
    walk( dis int32 ) bool
}
~~~

方法实现由方法的全名领起，跟随参数列表，返回值类型和实现代码块，样例代码如下：

~~~
Person::walk( dis int32 ) bool {

}
~~~

方法的参数数据类型为any时，数据类型可省。

~~~
add( a, b ) any {
  return a + b;
}
~~~

在方法的代码块中，可以书写`表达式语句`、`分支语句`、`循环语句`以及`流控制语句`。这些语句可以相互嵌套组合，用以描述方法的算法细节。在后续章节，我们将会逐一详解Alioth中的各种语句，但是在这之前，让我们先了解一下`量`之于Alioth的意义。

## 第四节 量

我们可以认为编程中的`量`系统`状态`的一个`分量`，按照取值特征，量可以被区分为`常量`和`变量`两大类。按照生命周期又可以将`量`区分为`静态量`和`动态量`。

每个`量`都具有其`数据类型`，不同数据类型的`量`具有不同的`值域`，当量的取值脱离其值域时，通常程序正在发生异常。

`常量`在其生命周期内，其值不发生改变，直接书写的`字面常量`和被标记为`const`的变量实际上都会成为`常量`。编译器可以假设`常量`在整个编译周期取值不变。在一些能够推断其值的地方，编译器可能不会为常量分配地址空间。

`变量`在其生命周期内取值可变，这需要计算机为其分配一块空间用于记录它的上一个状态，因为编译器不能假设它当前取值如何。

当然，在大多数情况下我们对`变量`等概念的定义会有所不同，比如当我们在讨论`变量类型`的概念时，我们认为`语言`中借以操作内存中对象的媒介即是`变量`。

## 第五节 变量类型

`变量类型`描述了一个变量无关数据类型的行为特征和物理特征。变量类型包括`实体`、`数组`、`引用`和`右值引用`四种。

### 实体

`实体`变量的物理结构与其所绑定的`对象`的物理结构保持一致。

使用实体变量传参时，基础数据类型会拷贝源对象的副本到被调方法的栈帧中，而复合数据类型变量则会在调用者的栈帧产生一个临时的拷贝，将此拷贝的指针传入被调者的栈帧。

由此可见，无论如何使用实体传参一定会拷贝对象。

在方法中创建实体变量的样例代码如下：

~~~
let x int32; // 创建一个变量，未初始化
let y float32 = 3.3; // 创建一个变量并初始化
let z = true; // 创建一个变量，不标注数据类型。编译器会自动推断数据类型
~~~

### 数组

`数组`变量是一种复合变量，用于实现数组数据结构。由于Alioth不允许使用数组声明参数或返回值，故而`数组`在Alioth中只是变量类型，而不是`数据类型`。数组变量中的每一个元素可以是实体也可以是引用，但是不能使用`右值引用`作为数组变量的元素。

受到类型描述符的限制，在类中声明的数组属性最多拥有`4k`个元素，且只有一个维度。

在方法中创建数组变量的样例代码如下：

~~~
let x[2][2] = [ [1,2], [3,4] ];
~~~

### 引用

`引用`变量的语义是扩展变量的有效作用域，必要时延长变量的生命周期。

在方法中创建引用变量的样例代码如下：

~~~
let &ref = obj;
~~~

我们不能直接修改引用的指向，但是有些时候我们有必要判断引用是否为空。空引用`nil`可以用于返回空引用或判断空引用。

`引用`变量具有固定的结构，在64位机器上的内存布局如下表所示：

|字段|偏移量|尺寸|备注|
|---|---|---|---|
|`typeid`|`0 B`|`4 B`|`对象`或`行为`的`typeid`|
|`offset`|`4 B`|`4 B`|对象在宿主中的偏移量|
|`agent`|`8 B`|`8 B`|宿主的`代理`指针|

当引用指向接口数据类型时，`typeid`字段将被用于检索`行为`$_{behavior}$，而对象的实际typeid在`行为`中能够找到。

`代理`是一种动态生成的隐藏结构，内部记录了对象的真实地址以及对象的引用计数，其结构如下表所示：

|字段|偏移量|尺寸|备注|
|---|---|---|---|
|`typeid`|`0 B`|`4 B`|对象的`typeid`|
|`attr`|`4 B`|`4 B`|属性信息<br/>`31 bit` : 对象是否在栈中<br/>`30-0 bit` : 指向此对象的引用计数|
|`object`|`8 B`|`8 B`|指向对象的指针|

`代理`指向的对象一定是一个没有宿主的对象，即此对象不是任何其他对象的属性。`代理`结构的重要作用是保护内存，考虑以下三种情况：

- 执行流离开对象的作用域时，对象的引用仍未销毁。
- 用户强制析构对象时，仍有引用指向对象。
- 引用指向一个对象的属性，当对象析构时，属性也会随之析构。

对上述第一个问题，编译器会将对象从栈移动到堆中来管理，并修改代理结构的`object`指针和`attr`标记。如此，其他引用无需知悉此变动，即可继续正确访问对象内存。

关于第二个问题，当对象被析构时，若代理体内的引用计数尚不为零，则代理体会被保留在内存中，但是`object`指针会被置空。当其他引用再次试图访问对象时，会抛出空指针异常。

最后一个问题，我们注意到，引用和代理的结构分别记录了属性的偏移量和宿主的真实地址，通过这样的设计，我们能够确保所有属性的引用的生命周期能够正确的受到宿主生命周期的影响。

### 右值引用

`右值引用`和`引用`的结构没有差别，但是`右值引用`携带了`右值语义`。`右值引用`表示源变量不再重要，其内部的数据可以被置换。

右值引用不能重定向，不能用作局部变量的变量类型。右值引用可以用作参数类型，也可以用做方法返回值类型，但是从方法返回的右值引用依然保持右值语义是不合理的。

下列代码展示了如何声明带右值引用参数的方法：

~~~
store( %frame FrameBuf ) void
~~~

## 第六节 表达式基础

`表达式`是一类重要的`语句`，使用表达式可以完成各类运算以及函数调度。

总体上，表达式可以分为`运算表达式`、`类型表达式`以及`lambda表达式`。

### 运算符基础

运算表达式由运算符和运算数连接而成，Alioth所支持的运算符如下表所示，`priority`数字越低表示优先级越高：

|运算符|结合性|目数|语义|优先级|
|---|---|---|---|---|
|`$`||前缀单目|反射|0|
|`.`|左结合|双目|成员|1|
|`#`|左结合|双目|切面|1|
|`::`|左结合|双目|作用域|1|
|`()`||后缀|函数调用|2|
|`[]`||后缀单目|下标|2|
|`++`||后缀单目|后置自增|2|
|`--`||后缀单目|后置自减|2|
|`&`||前缀单目|取地址|2|
|`%`||前缀单目|取右值引用|2|
|`*`||前缀单目|间接引用|2|
|`-`||前缀单目|负|3|
|`~`||前缀单目|反|3|
|`not`||前缀单目|非|3|
|`*`|左结合|双目|乘|4|
|`/`|左结合|双目|除|4|
|`%`|左结合|双目|余|4|
|`+`|左结合|双目|加|5|
|`-`|左结合|双目|减|5|
|`<<`|左结合|双目|左移|6|
|`>>`|左结合|双目|右移|6|
|`in`|左结合|双目|包含<br/>构成|7|
|`as`|左结合|双目|类型转换<br/>类型判定|7|
|`>`|左结合|双目|大于|8|
|`>=`|左结合|双目|大于等于|8|
|`<`|左结合|双目|小于|8|
|`<=`|左结合|双目|小于等于|8|
|`==`|左结合|双目|相等|9|
|`!=`|左结合|双目|不等|9|
|`&`|左结合|双目|与|10|
|`^`|左结合|双目|异或|11|
|`|`|左结合|双目|或|12|
|`and`|左结合|双目|并且|13|
|`or`|左结合|双目|或者|14|
|`=`<br/>`+=` `-=`<br/>`*=` `/=` `%=`<br/>`<<=` `>>=`<br/>`&=` `|=` `^=`|右结合|双目|赋值|14|
|`,`|左结合|双目|组|16|

大多数上述运算符均能够被重载，Alioth允许用户重载，删除，反重载以及同构重载特定的运算符，在一些运算符的重载过程中还可以携带额外的符号，将运行时错误静态化。关于运算符重载的话题我们会在后续章节详细讨论。

### lambda表达式

`lambda`关键字能够引领`lambda`表达式，如下代码展示了如何创建并存储一个lambda表达式：

~~~
let L = lambda ( x, y ) any { return x + y; };
~~~