# 前言

编程语言的设计始终是计算机领域的核心问题之一，从机器语言到低级语言再到高级语言，编程语言的进化历程从未停止过。如今，已知现存于世的编程语言种类已经超过自然语言的种类，基本能够满足任何类型的软件项目开发需求。然而每天仍有人尝试开发更先进的编程语言，从地下室里疯狂的极客到引领世界技术走向的商业巨头，编程语言的设计从来都不是满足需求即可，而是看到看不到的需求。

根据不同的侧面，高级语言可以存在若干分类形式，解释型与编译型，强类型与弱类型，指令式与函数式等。众多分类中的主流也在历史的长河中不断交替演化。如今包括Microsoft，Jetbrains，Facebook，Google在内的若干商界巨头都在开发自己的新型高级编程语言，关于编程语言的话题从来没有冷却过。

Alioth，作为一款面向对象的编译型强类型编程语言，挑战抽象本身的动态性，尝试支持超越编译周期的动态统一抽象体系。本书奉行概念先行的原则，向大家介绍了Alioth编程语言的设计。

限于篇幅，为了专注于Alioth编程语言特性的介绍，本文不得不假设您已经具备C++或其他类似等级的面向对象的高级编程语言的基础知识。

# 目录

- [前言](#前言)
- [目录](#目录)
- [第一章 开始](#第一章-开始)
  - [第一节 使用Alioth工作](#第一节-使用alioth工作)
  - [第二节 Alioth程序模型](#第二节-alioth程序模型)
  - [第三节 Alioth源码结构](#第三节-alioth源码结构)
- [第二章 编译资源管理](#第二章-编译资源管理)
  - [第一节 编写模块](#第一节-编写模块)
  - [第二节 包](#第二节-包)
  - [第三节 仓库](#第三节-仓库)
  - [第四节 工作空间](#第四节-工作空间)
- [第三章 Alioth基础](#第三章-alioth基础)
  - [第一节 Alioth类型系统初探](#第一节-alioth类型系统初探)

# 第一章 开始

`Alioth`是支持反射机制的面向对象的静态类型编程语言。

- `Alioth`的类型系统可以动态扩展。
- `Alioth`的语法对排版进行了限制。
- `Alioth`提供若干语法糖编码简单。

## 第一节 使用Alioth工作

使用Alioth编程语言可以参与大多数软件项目的开发，使用编译器从Alioth源代码可以产生单一的二进制编译产物。

您可以使用包管理工具安装或发布Alioth开发包。开发包中可以包含具有复用性的源码或编译产物以及对应的文档。编译器能够从工作路径和系统路径搜索已经被安装的开发包并使用其中的编译资源。

运行Alioth编译器编译Alioth源代码时，您需要一个正确的路径结构作为当前工作空间，Alioth编程语言的一些特性的正确实现依赖于此。Alioth编译器提供了初始化工作区的功能来协助您构造正确的工作路径结构。

~~~bash
#!/bin/bash

alioth --init hello
cd hello
~~~

我们会在关于工作空间的话题中详细了解编译器刚刚都做了些什么。现在，我们只需要在`hello/src`路径下创建我们的第一份`Alioth`源代码`hello/src/main.alioth`。

~~~alioth
module HelloWorld

using module stdio from 'alioth.stdlib'

main() => int32 {
    stdio.println("Hello world !")
}
~~~

这份源码实现了一个经典的`Hello world`程序，我们稍后再来剖析源码的细节，现在让我们体会一下成功的喜悦。

~~~bash
#!/bin/bash

alioth HelloWorld : run_me
~~~

编译器为我们产生了一个名为`run_me`的可执行程序，存放在`bin`路径下，我们现在来执行它。

~~~bash
#!/bin/bash

./bin/run_me
~~~

不出意外，你已经看到`Hello world !`跃然控制台，下一节我们会讨论上述活动中所涉及的概念，以及这些概念所体现的抽象思想。

## 第二节 Alioth程序模型

为了更好的支持Alioth编程语言的各种语法特性，我们对一些开发活动中涉及到的环节进行了抽象，我们将其总称为Alioth程序模型。

首先，编译指令`alioth HelloWorld : run_me`可以理解为`编译HelloWorld模块，输出到run_me文件`。

编译指令中没有提及源代码文件，而是指定了欲编译的`模块`。这是因为，编译资源管理的最小抽象单元就是`模块`。

模块是抽象概念，在工作空间内，一个庞大的模块可能需要多份源代码文件来共同描述，编译器会分析源码和模块的对应关系并按需读取源码文件。

在编译过程中产生目标代码文件时，一个模块仅对应产生一个目标代码文件，并最终参与链接。

实际上，在源代码层面上，对外部代码的依赖和引用也是以模块为单位进行的，Alioth应用程序完全由模块构成，没有任何同等级的其他抽象概念。

和Alioth工作流程相关的概念还包括`包`和`仓库`等，当我们足够深入Alioth时，会讨论这些话题。

## 第三节 Alioth源码结构

在真正开始学习Alioth编程语言之前，我们可以粗略浏览一下`Alioth`编程语言的源码文档中都可以写入哪些内容。

~~~alioth
module HelloWorld

using module stdio from 'alioth.stdlib'

main() => int32 {
    stdio.println("Hello world !")
}
~~~

上述是我们在第一节中用于实现HelloWorld功能的源码，一共七行。这份七行的源码可以被分为两个部分，`模块签名`和`正文`；

模块签名指的是前三行代码：

~~~alioth
module HelloWorld

using module stdio from 'alioth.stdlib'
~~~

模块签名指定了当前源码所属的模块，并且描述了这个模块与其他模块之间的依赖关系，并且详细解释了如何使用这些依赖。

第4行到第7行源码实现了一个名为`main`的方法，语法看起来和`TypeScript`语言有几分神似。

实际上，在一份Alioth源码中，您可以书写任何形式的定义，以及任何形式的实现，当然了这些抽象结构都必须属于当前模块。

对上述代码结构的剖析到这里就已经差不多了，最后您需要注意的是，Alioth是面向对象的编程语言，它并不提供面向过程的机制，也就是说，并不存在全局函数或全局变量。

基于上述描述，您一定会对我们的源码产生困惑，因为我们的`main`方法看起来并不属于任何一个类。

实际上，这是一个语法糖，模块中，与模块同名的类被称为`透明类`，它用于结构化的描述当前模块。在不需要被其他模块访问的情况下，透明类以及透明类中的任何声明都可以省略。这样的设计方便您对一小段代码进行测试，快速试验您的新想法，避免打扰您的思路。

既然说到这了，我们不得不展示一下，不使用这个语法糖时，源码看起来是什么样子的。

~~~alioth
module HelloWorld

using module stdio from 'alioth.stdlib'

class HelloWorld {
    main() => int32
}

HelloWorld.main() => int32 {
    stdio.println("Hello world !")
}
~~~

# 第二章 编译资源管理

本章初步讨论编译资源的管理，如果您更关心编码的细节，本章的第二节以及之后的内容都可以暂时跳过。

## 第一节 编写模块

模块是一个抽象概念，它在编码，编译，链接等不同阶段具有不同的体现形式。模块的概念贯穿了Alioth抽象体系，将不同问题域中的抽象概念连接起来。

Alioth源码必须从`模块签名`语法结构开始，在它之前，除了注释和空白符以外任何语法结构都是非法的。

模块签名描述了模块的名称，模块对其他模块的依赖关系。如果一个模块分散在若干份源码中，那么模块签名中的依赖关系也可以分散开写，不影响实际含义。

模块签名由`module`关键字引领，跟随一个模块名称；最简单的模块签名如下：

~~~alioth
module Hi
~~~

可选地，可以在模块签名后面追加若干`依赖描述`语法结构，来描述模块对其他模块的依赖关系。

依赖描述语句由关键字`using`引领，包含欲导入的模块名，模块所在包标识符以及可选的模块别名

~~~alioth
using netty from "godgnidoc.template" as net
~~~

特别地，如果依赖项的别名为`this`则依赖项中的符号均被注入当前模块，依赖项便不具备名称。

如下代码展示了一个相对复杂的模块签名。

~~~alioth
module iTalk

using module stdio from 'alioth.stdlib' as this
using module jsonz from 'godgnidoc.utils" as json
using module agent from 'godgnidoc.utils"
~~~

在上面的讨论中，我们遇到了一些依赖需要指定它所属的包，关于包的使用，我们详见下一节。

## 第二节 包

在组织编译资源时，一个模块对应于若干源码文件，当发布应用程序编程库时若干个相关联的模块总是被一起下载，一起使用。我们使用包来集中管理若干个相关联的模块。

从实质角度，包是对编译资源的集中管理单位，其中可以包含源码，文档，编译产物等内容。从抽象角度，包是模块的集合。我们推荐使用`包`的形式构建并发布您开发的Alioth编程库。如此您就能享受Alioth仓库机制为您提供的版本管理，发布和下载服务了。

应当注意，Alioth仓库提供的版本管理功能不同于`git`等版本管理工具，Alioth仓库仅对发布版本进行管理，请不要依赖Alioth仓库来保护您的源码。

Alioth使用`仓库`管理`包`，当您安装了Alioth编译器，您会获得一个内置在Alioth编译器安装路径的仓库，称为`根仓库`。

`根仓库`中的`包`可以被任何Alioth项目引用。您也可以在项目本地建立仓库，对于同名的包，Alioth编译器优先使用`本地仓库`中的包。

在工作过程中，我们可以使用5个维度来唯一确定一个包：

- `发布者`

  同一个发布者发布的包会被集中管理，起到命名空间的作用。在绝大多数情况下，发布者是用于确定一个包的必须信息之一。

  发布者是一个平坦的字符串，可由英文字母，数字和下划线构成。
- `包名称`

  用于确定一个包的必须信息，可由英文字母，数字和下划线构成。
- `架构`
  - `x86`
  - `x86_64`
  - `arm_v7`
  - `...`

  包对应的平台架构，通常默认为当前架构，不是必须给出的信息。
- `系统`
  - `none`
  - `windows`
  - `linux`
  - `...`

  包对应的操作系统，通常默认为当前操作系统，不是必须给出的信息。
- `版本`

  包的版本号的格式是三段式：`major.minor.patch`，每段版本号升级的含义如下：

  - `patch`表示对当前架构进行小修补，小优化，向下兼容。
  - `minor`表示在当前体系下增添特性，向下兼容。
  - `major`表示重大升级，向下不兼容或体系变化。

我们通常在工作空间的配置文件中指定开发包的版本、系统和架构，而在编码时，我们通常只需要考虑包的发布者和名称。

## 第三节 仓库

Alioth始终使用`仓库`来集中管理`包`，编译器能够直接使用的仓库包括`根仓库`和`本地仓库`。

您也可以使用包管理工具从`远程仓库`下载安装被发布的`包`，安装指令看起来长这样：

~~~bash
#!/bin/bash

alioth package: -i godgnidoc.jsonz
~~~

您可以带上更多参数执行指令来安装某个特定版本，平台或系统对应的包；关于更详细的指令格式可以在编译器使用手册上找到答案。

如果您想发布您的包到某个远程仓库，首先您需要确保将`公钥`送入该远程仓库。具体该如何实现这一点，取决于该远程仓库的运营者希望您做什么。

当您完成了发布者身份的注册，推送包的指令看起来长这样：

~~~bash
#!/bin/bash

alioth package: --publish jetweb
~~~

`jetweb`是您在`packages.json`文件中声明的一个包，关于这个包的详细信息都写在这份文件中，具体格式您可以在编译器手册中找到描述。

上述指令会将一个包发布到所有的已知远程仓库，在编译器的根目录有一个配置文件记录了这些仓库的相关信息。

本书更着重讲解Alioth编程语言，更多关于编译器功能使用方法请参见`Alioth编译器手册`。

## 第四节 工作空间

Alioth始终要求您在一个干净整洁，结构正确的工作空间开始您的工作。Alioth编译器对编译过程中所涉及的所有资源的部署规则进行了详细的设定，包括编译产物的存放路径也有详细的规定。

作出如此详细的规定自然不是为了束缚开发者的手脚，而是为了对所有编译资源中包含的信息进行充分的利用。甚至是编译产物，在编译期间也可能被读取，分析。除此之外，严格的路径安排也有助于Alioth编译器对资源进行自动管理，在封装发布和安装一个包的时候能够减少您的工作量。

综上，Alioth规定工作空间中有9个标准子路径：

- `arc`：用于存放作为编译产物的静态链接库。
- `bin`：用于存放作为编译产物的可执行文件。
- `doc`：用于存放说明文档。
- `inc`：用于存放头文件。
- `lib`：用于存放作为编译产物的动态链接库。
- `obj`：用于存放编译中间产物，比如目标代码文件。
- `repo`：用作本地仓库，管理本地安装的包。
- `src`：用于存放源文件。
- `test`：用于存放测试单元。

Alioth语言在设计上倾向于将头文件和源文件分开编写的源码模型。Alioth编程语言禁止在定义语法结构中写入算法实现。这是因为，我们认为一份干净的定义文件有助于团队协作，并且能够加快编译速度。

# 第三章 Alioth基础

本章讲解Alioth编程语言的基础内容，讲解了Alioth编程语言是如何设计和实现的。我们对Alioth编程语言的类型系统进行了初探，了解了一些基础语法结构的书写，为后续章节探索高级语法特性做准备。

## 第一节 Alioth类型系统初探

Alioth被设计为类型系统可动态扩展的语言，这意味着您可一从输入流读取一个类型，并使用这个类型创建新的对象。Alioth的类型系统是复杂的，当前章节仅对基础编程所必备的概念进行讨论。

Alioth使用`类型表达式`来计算类型，并不是所有的情况都要求类型表达式在编译期可求值。

- 原始类型（primitive types)
- 复合类型（composite types）