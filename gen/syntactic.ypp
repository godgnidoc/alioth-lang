%code top {
#include "syntactic.hpp"
#include "lexical.hpp"
}

%code requires {
#include "syntax.hpp"
#include "token.hpp"

namespace alioth {
class Lexer;
}
}

%code provides {
namespace alioth {

    /** Start Condition, 由语法分析器用于修改词法分析器语境 */
    enum class SC {
        INITIAL,
        /** @MARK[SC] */
        DEPENDENCY,
        EXPRESSION,
    };

    /** 终结符ID */
    using VT = Parser::token_kind_type;

    /** 非终结符ID */
    using VN = Parser::symbol_kind_type;

    /** 获取终结符记号名称 */
    std::string kind_name( alioth::VT t );

    /** 获取非终结符记号名称 */
    std::string kind_name( alioth::VN n );

    /** 获取终结符或非终结符记号名称 */
    std::string kind_name( int i );
}
}

%code {
namespace alioth {
    template<typename ... Args>
    void kick( Args ... args ) {
        (node_t(args), ...);
    }
}

using namespace alioth;

st_node* fetch( st_node* res, st_node* lhs = nullptr, st_node* rhs = nullptr);
}

%glr-parser
%language "C++"
%require "3.7"
%defines "syntactic.hpp"
%output "syntactic.cpp"
%token-table
%locations

%parse-param { alioth::Lexer& yylex }
%parse-param { alioth::doc_t& doc }
%initial-action {
}

%destructor { {if( $$ ) { node_t node = $$;} } } <>

%define api.location.file "location.hpp"
%define api.parser.class {Parser}
%define api.namespace {alioth}
%define api.value.type {st_node*}
%define api.token.prefix {TK_}
%define api.token.raw
%define parse.error verbose

%token SPACE COMMENT
%token CONST
%token AS LET USE IN IMPORT FROM
%token CLASS ENUM UNIT INTERFACE MODULE
%token IF ELSE FOR WHILE DO RETURN BREAK CONTINUE
%token PUBLIC PRIVATE PROTECTED
%token ID INTEGER DECIMAL OCTAL HEX TRUE FALSE NULL DQSTR SQSTR THIS
%token COMMA COLON SEMI
%token OPE CLE OPI CLI OPB CLB
%token DOT ETC MOL BITAND BITOR BITXOR BITNOT SHL SHR
%token ASS ASS_ADD ASS_SUB ASS_MUL ASS_DIV ASS_MOL ASS_SHL ASS_SHR ASS_BITAND ASS_BITOR ASS_BITXOR

%right ASS ASS_ADD ASS_SUB ASS_MUL ASS_DIV ASS_MOL ASS_SHL ASS_SHR ASS_BITAND ASS_BITOR ASS_BITXOR
%nonassoc NOT
%left AND 
%left OR XOR
%left ADD SUB
%left MUL DIV MOL
%nonassoc SUP QST
%left DOT

%start doc

%%

doc:
    doc.header doc.body {
        auto hdr = (st_nters*)$1; auto res = new st_doc;
        hdr->outqueue((node_t&)res->modecl);
        for( auto import : *hdr ) res->imports.push((import_t)import);
        for( auto stmt : *(st_nters*)$2 ) res->body.push(stmt);
        $$ = doc = fetch(res, $1); };

doc.header:
    modecl { 
        auto res = new st_nters(); 
        res->push($1); 
        $$ = fetch(res, $1); }
    | doc.header import { 
        auto res = (st_nters*)$1; 
        res->push($2); 
        $$ = fetch(res, $1, $2); };

doc.body:
    %empty {
        auto res = new st_nters();
        $$ = res; }
    | doc.body enum {
        ((st_nters*)$1)->push($2);
        $$ = $1; };
enum:
    ENUM ID OPB enum.items CLB {
        auto res = new st_enum;
        res->name = $2;
        for( auto enumi : *(st_nters*)$4 )
            res->items.push((enumi_t)enumi);
        $$ = fetch(res, $1, $5);
        kick($1, $2, $3, $4, $5);
    };

enum.items:
    enumi {
        auto res = new st_nters();
        res->push($1);
        $$ = fetch(res, $1); }
    | enum.items enumi {
        ((st_nters*)$1)->push($2);
        $$ = fetch($1, $1, $2); }
    | enum.items COMMA enumi {
        ((st_nters*)$1)->push($3);
        $$ = fetch($1, $1, $3);
        kick($2); };

enumi:
    ID {
        auto res = new st_enumi;
        res->name = $1;
        $$ = fetch(res, $1); }
    | ID ASS DECIMAL {
        auto res = new st_enumi;
        res->name = $1;
        res->value = $3;
        $$ = fetch(res, $1, $3);
        kick($2); };
modecl:
    MODULE ID { 
        auto res = new st_modecl; 
        res->name = $2; 
        $$ = fetch(res, $1, $2); 
        kick($1); };

import:
    IMPORT { yylex.begin(SC::DEPENDENCY); } import.modules FROM import.package { 
        auto deps = (st_nters*)$3;
        auto res = new st_import;
        res->from = $5;
        for( auto dep : *deps )
            res->modules.push((modesc_t)dep); 
        $$ = fetch(res, $1, $5); 
        kick($1, $4, $5);
        yylex.begin(SC::INITIAL); };

import.package: DQSTR | SQSTR;

import.modules:
    modesc { 
        auto res = new st_nters(); 
        res->push($1); 
        $$ = fetch(res, $1, $1); }
    | import.modules COMMA modesc { 
        auto res = (st_nters*)$1; 
        res->push($3); 
        $$ = fetch(res, $1, $3);
        kick( $2, $3); };

modesc:
    ID { 
        auto res = new st_modesc; 
        res->module = $1; 
        $$ = fetch(res, $1, $1);
        kick($1); }
    | ID AS ID { 
        auto res = new st_modesc;
        res->module = $1; 
        res->alias = $3; 
        $$ = fetch(res, $1, $3); 
        kick($1, $2, $3); };
/** @MARK[RULE] */

%%

namespace alioth {
    std::string kind_name( alioth::VT t ) {
        return yysymbol_name((alioth::VN)t);
    }

    std::string kind_name( alioth::VN n ) {
        return yysymbol_name(n);
    }
    std::string kind_name( int i ) {
        return yysymbol_name((alioth::VN)i);
    }

    void Parser::error( const location_type& loc, const std::string& msg ) {
        std::cerr << loc << ' ' << msg << std::endl;
    }
}

st_node* fetch( st_node* res, st_node* lhs, st_node* rhs) {
    if( lhs )
        res->loc = lhs->loc;
    if( rhs )
        res->loc += rhs->loc;
    return res;
}